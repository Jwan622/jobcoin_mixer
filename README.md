## Jobcoin Mixer


# Table of Contents
1. [Getting Started](#getting-started)
2. [How to use the app](#app-usage)
3. [Code Analysis](#code-analysis)
   1. [Jobcoin Client](#jobcoin-client)
   2. [TransactionHandler](#transaction-handler)
   3. [Distributors](#distributors)
   4. [Edge Case](#edge-case)
   5. [Room for Improvement](#room-for-improvement)
4. [Image Choice](#image-choice)

# Getting Started

After cloning the repo, cd into the folder and run:

```
rackup -p 3000
```
and go to `localhost:3000` in your browser.

(You might have to run `bundle install` if you see any errors, but I believe the `config.ru` file is written so that you only need to run the `rackup` command.)


Do not run the application using ruby:

```ruby
ruby './app.rb' -p 3000
```
The above will bypass the configuration in `config.ru`

# App Usage
After going to localhost:3000:

1. Fill in your addresses to mix. These addresses are the ones you are trying to make transfers to opaque. You can enter 1 or more addresses. If you enter in 2 addresses and your company transfers 2 Jobcoins to the generated mixed address, our mixer will distribute 1 Jobcoin to each address.
2. Once you've entered in the addresses, click the `Mix
Addresses` button. The app will provide you a mixed address that you can direct transfers to.
3. Once you received your mixed address, you will see a deposit section where you can enter in the address that you wish to send Jobcoins from in the `Deposit From` box. Your new mixed addresses should already be prepopulated in the `Deposit To` box.
4. Enter in the deposit amount in the `Deposit Amount` field.
5. Click `Deposit`. At this point, the application will transfer Jobcoin from the address that you entered in the `Deposit From` box to the mixed address that was in the `Deposit To` box. After that's complete, the Jobcoin will then be transferred to a House Account belonging to the application. Finally, the Jobcoin is evenly distributed to the addresses that were originally used to create the mixed address.
7. Wait for confirmation message "Deposit Complete!" to appear in red. At that point, the Jobcoin that was sent to the mixed address should have transferred back to your original address(es).

#### Example
Say you own 2 addresses: `Addr1` and `Addr2`. Your company's boss wants to transfer 5 Jobcoin to you. So, you provide your boss your mixed address (let's call it `Addr3`) and he makes the transfer of 5 Jobcoin to the mixed address from his address: `BossAddress`. He enters in your mixed address, his address, and 5 Jobcoin into the deposit form and submits the form.

4 transactions should have taken place:
- Transfer from `BossAddress` to `Addr3` (the mixed address) for 5 Jobcoin.
- Transfer from `Addr3` to the House Account for 5 Jobcoin.
- Transfer from the House Account to `Addr1` for 2.5 Jobcoin.
- Transfer from the House Account to `Addr2` for 2.5 Jobcoin.

# Code Analysis

Let's give a bit into the code and decisions.

### Jobcoin Client

The code needed to interact with the Jobcoin API is located inside the `jobcoin_client` gem. Extracting the logic of interacting with the API seemed reasonable for a couple of reasons:
1. The client is reusable for any application that needs to interact with the Jobcoin API.
2. If we build several applications interacting with the Jobcoin API and the API changes, changes to the client only need to occur in one place (the gem).

The gem repo is [here](https://github.com/Jwan622/jobclient_api).

### Transaction Handler

Let's say we have these transactions.

```
[
  {"timestamp"=>"2018-01-18T02:57:34.959Z", "toAddress"=>"Alice", "amount"=>"50"},
  {"timestamp"=>"2018-01-18T02:57:35.016Z", "fromAddress"=>"Alice", "toAddress"=>"Bob", "amount"=>"12.5"},
  {"timestamp"=>"2018-01-18T16:53:16.747Z", "toAddress"=>"50", "amount"=>"50"},
  {"timestamp"=>"2018-01-18T16:53:27.572Z", "fromAddress"=>"50", "toAddress"=>"alice", "amount"=>"50"},
  {"timestamp"=>"2018-01-18T16:53:38.853Z", "fromAddress"=>"alice", "toAddress"=>"Alice", "amount"=>"50"},
  {"timestamp"=>"2018-01-23T23:35:03.792Z", "fromAddress"=>"Alice", "toAddress"=>"alice", "amount"=>"10"},
  {"timestamp"=>"2018-01-23T23:35:25.464Z", "fromAddress"=>"Alice", "toAddress"=>"Bob", "amount"=>"1"},
  {"timestamp"=>"2018-01-23T23:35:48.835Z", "fromAddress"=>"Alice", "toAddress"=>"Bob", "amount"=>"1"},
  {"timestamp"=>"2018-01-23T23:47:46.485Z", "fromAddress"=>"Alice", "toAddress"=>"Bob", "amount"=>"1"},
  {"timestamp"=>"2018-01-23T23:48:31.953Z", "fromAddress"=>"Alice", "toAddress"=>"Bobz", "amount"=>"1"},
  {"timestamp"=>"2018-01-24T18:11:04.444Z", "fromAddress"=>"Alice", "toAddress"=>"Bobz", "amount"=>"1"}
]
```

The `TransactionHandler` will filter out transactions that were sent to global addresses not generated by our mixer. Since we'll be only transferring funds sent to mixed address generated by the mixer to our House Account, we first need to filter for these transactions.

```ruby
TransactionService.new(transaction_history, HouseDistributor::IDENTIFIER).process
```

In the above code, the `TransactionService` takes in global Jobcoin transactions (obtained directly from the Jobcoin API) and an identifier. It will return transactions sent to mixed addresses containing the identifier (the identifier will be encrypted in the mixed address) and process them to this format:

```ruby
[
  {"toAddress"=>"Bob", "amount"=>"15.5"},
]
```

The above information will be returned if `Bob` is an encrypted address that contains the identifier. `Bob`, when decrypted, could look something like this:

```ruby
['address1', 'address2', <identifier>]
```

The identifier at the end of the array allows our mixer to see which of the global transactions were to addresses generated by us.

### Distributors

One thing that came to mind when writing the Distribution logic was making the distribution process idempotent. If at any point the transfer fails (Jobcoin API is down, network connection issues, our Mixer crashes, edge cases, etc.), the distribution process should be able to safely rerun without running the risk of duplicate or missing transfers.

Let's do some scenario analysis on some possible failures and how our logic handles it:
- Scenario: Jobcoin does not transfer from mixed address to House Account.
This is the relevant code:

  ```ruby
  def to_aggregate_account
    transactions.each do |trans|
      from_address = trans['toAddress']
      remaining_balance = client.address_transactions(from_address)['balance'].to_f

      # this will throw an error if we try to transfer an amount greater than
      # what's in the from_address or if we try to transfer 0.0. So, we will
      # only transfer an amount > 0
      # Also, if someone tries to transfer from house to an encrypted address, the transfer should
      # be returned back to the House Account here.
      client.add_transaction(
        from_address,
        self.class::AGGREGATE_ACCOUNT,
        remaining_balance
      ) if remaining_balance > 0.0
    end
  end
  ```

  The `transactions` provided to the Distributor is already processed and contains all of the mixed addresses that need to be emptied. All this is doing is looking up the balance on each of these mixed address. If there is any balance remaining, we then transfer it to the House Account. If there is no balance, no transfer is made. So it seems like the Distributor can be rerun safely.

- Scenario: Jobcoin does not transfer from House Account to original individual addresses.
This is the relevant code:

  ```ruby
  def to_original_addresses
    liabilities = AccountingService.new(self.class::AGGREGATE_ACCOUNT).liabilities

    # make distributions from AGGREGATE_ACCOUNT to original accounts
    liabilities.each do |addr, amount|
      client.add_transaction(self.class::AGGREGATE_ACCOUNT, addr, amount)
    end
  end
  ```

  and inside the `AccountingService`

  ```ruby
  def liabilities
    @contributions.merge(@distributions) do |key, con, dis|
      (BigDecimal.new(con.to_s) - BigDecimal.new(dis.to_s)).to_f
    end.select { |addr, amount| amount != 0.0 && @contributions.keys.include?(addr) }
  end
  ```

  The distribution from the House Account to the individual addresses calls the `AccountingService` to determine how much the House Account needs to send to each individual address. That service recalculates liabilities every time which is the difference between how much each individual account has contributed to the House Account and how much the House Account has transferred to each individual account. If there is a discrepancy between the two, then there is a liability and the mixer will make a transaction. If there is no discrepancy (i.e. the liability was already settled), then no transaction is made.

  If the mixer or API fails when the mixer has only resolved half of the liabilities, we can still safely rerun the `to_original_addresses` method. The liabilities that were settled do not return from the `AccountingService` and the liabilities that were not settled before the failure will still return from the `AccountingService`. So, this can be safely rerun.

Lastly, if the initial deposit to the mixed address fails, we display an error message to the client and the transaction is never made, so no Jobcoin is moved. The client can retry the transaction safely.

There are some issues with how the distribution logic is written and I address them in the sections [Edge Cases](#edge-cases) and [Room for Improvement](#room-for-improvement).

### Edge Case
If you mix 3 addresses and then deposit an amount of JobCoin into the mixed address that does not divide evenly 3 ways, you wind up with more coins. For example:

_Scenario_:
You mix 3 addresses and then try to transfer 2.3 JobCoin to the mixed address. When distributing the 2.3 Jobcoin from the House Account to each of the
three addresses, the House Account will transfer 0.7666666666666667 JobCoin to each address which, when multiple by 3, comes out to more than 2.3. This is a bug that should be fixed since we can create infinite JobCoin this way.

_Solution_:
Some check before the final transfers should be made that compares the total of the individual transfers with the original transferred amount to the mixed address. If the numbers do not match, some adjustment should be made to the individual transfers to match the original transfer.

### Room for improvement.

Immediately after finishing the project, I felt a few areas could be improved if I had more time:

1. I wrote the `Distributors` with the Strategy pattern in mind, but I feel like my attempt at making the distributor uncoupled from the logic of Mixed => House => original addresses transfers is not well done. For example:

  ```ruby
  # Inside the Distributor class
  def to_aggregate_account
    transactions.each do |trans|
      from_address = trans['toAddress']

      ...
      client.add_transaction(
        from_address,
  ```

  The above code already assumes that the transfer is going from the mixed address to the House Address and leave no room for this business logic to be changed. This logic is hard-coded into the `Distributor` class and the `HouseDistributor` merely provides identifiers and the account to make the transfer to. If say, in the future, we wanted to make several additional transfers along the way, the distributor as currently written does not allow for that.

  I think a better choice would have been to write something like this:

  ```ruby
  house_distribution = HouseDistribution.new
  Distributor.new(house_distribution, transactions).make_transfers
  ```

  and inside the Distributor:

  ```ruby
  def make_transfers
  transactions.each do |trans|
    distribution.execute(trans)
    ...
  ```

  and have the provided specific distributor handle how to implement its own distribution rules. I think this would be more extensible design.

2. The `TransactionService` is also pretty coupled with the current transfer logic. It only filters by the `toAddress`. Eh, this is probably fine actually. I don't really see a need for filtering by other criteria in the foreseeable future of mixing addresses...I think?

3. I should make the `MixerWorker` job asynchronous. Since the worker distribution is idempotent, I don't see this work can't just happen in the background and just give the client a success message if the deposit to the
mixed account succeeds. If there is a failure on our end, we can retry the work after fixing the data, knowing that it's safe and
will succeed eventually.

4. I found a bug when the house account has less money than the liabilities. For example, in this scenario:

  ```
  liabilities = { a: 1, b:2, c:3 }
  >house_account_balance> = 5
  ```

  As written, our distributor would pay `a` and `b`, but `c` would remain unpaid until the next round of contributions. This would lead to the owner of these addresses only being paid for some of his/her money. This issue would carryover to the next customer until the HouseAccount has sufficient funds to cover all liabilities.

  This shouldn't ever happen... but it could. I think because
  of this bug and the edge case described above, some transfer checker needs to be implemented before distribution to ensure that:
  1. The distributions to the individual accounts match the transfers from
  the individual accounts before sending them to avoid the edge case.
  2. There are sufficient funds. If not, borrow Jobcoin perhaps.

  The proposed `Checker` class could go right here:

  ```ruby
  def to_original_addresses
    liabilities = AccountingService.new(self.class::AGGREGATE_ACCOUNT).liabilities
    # Proposed Checker Class could go here!
    liabilities.each do |addr, amount|
      client.add_transaction(self.class::AGGREGATE_ACCOUNT, addr, amount)
    end
  ```

# Image Choice
This multi-layered structure in the Yo Dawg meme makes it reminiscent of the “strange loops” described in Douglas Hofstadter’s Gödel, Escher, Bach. Strange loops occur when, by moving only upwards or downwards through a system, one finds oneself back where one started... kind of like what goes on in this mixer system. So, the Xhibit meme was the one clear choice.
